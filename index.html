<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>BeWater</title>
<style>
body, html { overflow-x: hidden; }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background-color: #1a2639;
            font-family: monospace;
            color: #a7b6c7;
        }
        
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            cursor: crosshair;
            background: linear-gradient(to bottom, 
                /* Sky section - 15% */
                #2c3e50 0%, 
                #344963 8%,
                #3a5472 15%,
                /* Ocean horizon line with subtle transition */
                #3c5a78 15.5%,
                /* Ocean gradient - 75% */
                #3c5a78 16%, 
                #365472 30%,
                #304b68 40%,
                #2a425e 50%,
                #243952 60%,
                #1e3046 70%,
                #1a2639 80%,
                #152030 90%,
                /* Ocean floor - 10% */
                #101824 100%);
        }
        
        #horizon {
            position: absolute;
            top: 15vh;
            left: 0;
            width: 100%;
            height: 1px;
            background-color: #6c8bab;
            opacity: 0.5;
        }
        
        #ocean {
            position: absolute;
            top: 15vh;
            left: 0;
            width: 100%;
            height: 85vh;
            overflow: hidden;
        }
        
        .character-fish {
            position: absolute;
            font-size: 16px;
            color: rgba(167, 182, 199, 0.7);
            pointer-events: none;
            text-shadow: 0 0 3px rgba(167, 182, 199, 0.3);
            transition: transform 0.3s ease-out;
        }
        
        .ascii-art-container {
            position: absolute;
            z-index: 200;
            pointer-events: none;
            white-space: pre;
            font-family: monospace;
            color: rgba(167, 182, 199, 0.9);
            text-shadow: 0 0 5px rgba(167, 182, 199, 0.5);
        }
        
        /* Track morphing cooldowns */
        .morph-cooldown {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: #a7b6c7;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1000;
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 0;
            color: #a7b6c7;
            font-size: 14px;
            opacity: 0.7;
            z-index: 1000;
            pointer-events: none;
        }
        
        /* Pixel texture overlay */
        body::after {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAYAAABytg0kAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABZJREFUeNpi/M/A8J+RkZGRATsACDAADQAGLyizrw8AAAAASUVORK5CYII=');
            pointer-events: none;
            opacity: 0.3;
            z-index: 1000;
        }
        
        /* Ocean wave animation */
        #ocean::before {
            content: '';
            position: absolute;
            width: 200%;
            height: 100%;
            top: 0;
            left: 0;
            background: repeating-linear-gradient(
                transparent,
                transparent 50px,
                rgba(167, 182, 199, 0.05) 50px,
                rgba(167, 182, 199, 0.05) 51px
            );
            animation: waveMotion 20s linear infinite;
        }
        
        @keyframes waveMotion {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }
        
        /* Water particles */
        .water-particles {
            position: absolute;
            width: 100%;
            height: 85vh;
            top: 15vh;
            left: 0;
            overflow: hidden;
            pointer-events: none;
            z-index: 20;
        }
        
        .particle {
            position: absolute;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            opacity: 0.3;
        }
        
        /* Character burst container */
        .character-burst-container {
            position: absolute;
            pointer-events: none;
            z-index: 100;
        }
        
        /* Pixel wave animation */
        @keyframes waveRipple {
            0% { transform: translateY(0); opacity: 0.95; }
            25% { transform: translateY(-8px); opacity: 1; }
            50% { transform: translateY(-15px); opacity: 0.9; }
            75% { transform: translateY(-25px); opacity: 0.6; }
            100% { transform: translateY(-40px); opacity: 0; }
        }
        
        @keyframes wavePeakFloat {
            0% { transform: translateY(0) rotate(0deg); opacity: 0.95; }
            30% { transform: translateY(-15px) translateX(5px) rotate(8deg); opacity: 1; }
            60% { transform: translateY(-30px) translateX(10px) rotate(15deg); opacity: 0.7; }
            100% { transform: translateY(-45px) translateX(15px) rotate(20deg); opacity: 0; }
        }
        
        @keyframes waveBase {
            0% { transform: translateY(0); opacity: 0.95; }
            30% { transform: translateY(-5px); opacity: 1; }
            70% { transform: translateY(-15px); opacity: 0.8; }
            100% { transform: translateY(-30px); opacity: 0; }
        }
        
        @keyframes waveSplash {
            0% { transform: translateY(0) scale(1); opacity: 0.9; }
            50% { opacity: 1; transform: translateY(-20px) translateX(3px) scale(0.7); }
            100% { transform: translateY(-35px) translateX(6px) scale(0.3); opacity: 0; }
        }
        
        /* Right-click ripple effect */
        .ripple-effect {
            position: absolute;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 50;
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.6);
            opacity: 0;
            animation: rippleExpand 1.5s cubic-bezier(0.1, 0.5, 0.1, 1) forwards;
        }
        
        @keyframes rippleExpand {
            0% { transform: scale(0.2); opacity: 0; }
            20% { opacity: 0.8; }
            100% { transform: scale(1); opacity: 0; }
        }
        
        /* Character animation from ripple */
        @keyframes charFromRipple {
            0% { transform: scale(0.1) rotate(0deg); opacity: 0; }
            50% { transform: scale(1.2) rotate(180deg); opacity: 1; }
            100% { transform: scale(1.0) rotate(360deg); opacity: 0.8; }
        }
        
        /* Morph animation container */
        #ascii-morph-container {
            position: absolute;
            z-index: 300;
            pointer-events: none;
            white-space: pre;
            font-family: monospace;
            color: rgba(167, 182, 199, 0.9);
            text-shadow: 0 0 5px rgba(167, 182, 199, 0.5);
            display: none;
        }
        
        /* Character glow effect during transformation */
        @keyframes charGlow {
            0% { text-shadow: 0 0 5px rgba(167, 182, 199, 0.5); color: rgba(167, 182, 199, 0.7); }
            50% { text-shadow: 0 0 20px rgba(167, 182, 199, 0.9); color: rgba(220, 230, 240, 1); }
            100% { text-shadow: 0 0 5px rgba(167, 182, 199, 0.5); color: rgba(167, 182, 199, 0.7); }
        }
        
        /* Show cooldown indicator */
        .cooldown-active {
            opacity: 1 !important;
        }
/* Timer Display */
#timer-container {
    position: fixed;
    top: 20px;
    right: 20px;
    background: rgba(0, 0, 0, 0.7);
    padding: 10px 15px;
    border-radius: 5px;
    font-family: monospace;
    color: #a7b6c7;
    font-size: 18px;
    z-index: 1000;
    border: 1px solid rgba(167, 182, 199, 0.3);
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
}

/* End Game Screen */
#end-game-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.85);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 2000;
    flex-direction: column;
    font-family: monospace;
    overflow: auto;
    padding: 20px;
}

#end-game-content {
    background: rgba(26, 38, 57, 0.9);
    padding: 30px;
    border-radius: 8px;
    max-width: 80%;
    text-align: center;
    border: 1px solid rgba(167, 182, 199, 0.5);
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
}

#ending-title {
    font-size: 24px;
    color: #fff;
    margin-bottom: 20px;
    letter-spacing: 2px;
    text-shadow: 0 0 10px rgba(167, 182, 199, 0.7);
}

#ending-message {
    font-size: 16px;
    color: #a7b6c7;
    line-height: 1.6;
    margin-bottom: 30px;
    white-space: pre-wrap;
    text-align: left;
}

#restart-button {
    background: rgba(60, 90, 120, 0.7);
    border: none;
    color: #a7b6c7;
    padding: 10px 20px;
    font-size: 16px;
    border-radius: 5px;
    cursor: pointer;
    font-family: monospace;
    transition: all 0.3s;
    border: 1px solid rgba(167, 182, 199, 0.3);
}

#restart-button:hover {
    background: rgba(80, 120, 160, 0.9);
    transform: scale(1.05);
}

.ending-ascii-art {
    margin: 20px 0;
    color: #a7b6c7;
    font-size: 10px;
    line-height: 1.2;
    text-align: center;
    white-space: pre;
}

/* Collection counter for debugging */
#collection-counter {
    position: fixed;
    top: 60px;
    right: 20px;
    background: rgba(0, 0, 0, 0.7);
    padding: 5px 10px;
    border-radius: 5px;
    font-family: monospace;
    color: #a7b6c7;
    font-size: 12px;
    z-index: 1000;
    display: none; /* Hidden by default, can be shown for debugging */
}
    </style>


<style>
    
.ufo {
    position: absolute;
    top: 5vh;
    left: 0;
    width: 128px;
    height: 128px;
    background-image: url('https://cdn.glitch.global/9b9abd46-ae9c-4206-81ff-05f9117caf41/catalien.png?v=1745397274802');
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 300;
    pointer-events: none;
    image-rendering: pixelated;
}

.beam {
    position: absolute;
    top: calc(5vh + 74px); /* ‰ΩçÁΩÆÂú®UFOÊ≠£‰∏ãÊñπ */
    width: 240px; /* ÂÆΩÂÖâÊü± */
    height: 70vh;
    /* ‰∏äÊ∑±‰∏ãÊµÖÁöÑÊ∏êÂèòËâ≤ */
    background: linear-gradient(
        to bottom,
        rgba(150, 220, 255, 0.3) 0%,
        rgba(180, 230, 255, 0.25) 20%,
        rgba(200, 240, 255, 0.2) 40%,
        rgba(220, 245, 255, 0.15) 60%,
        rgba(230, 250, 255, 0.1) 80%,
        rgba(255, 255, 255, 0.05) 100%
    );
    clip-path: polygon(30% 0%, 70% 0%, 100% 100%, 0% 100%);
    z-index: 299;
    pointer-events: none;
    filter: blur(3px);
    /* Ê∑ªÂä†ÂæÆÂº±ÁöÑÂèëÂÖâÊïàÊûú */
    box-shadow: 0 0 15px rgba(150, 220, 255, 0.1);
}
</style>


</head>
<body>
<div id="game-container">
<div id="horizon"></div>
<div id="ocean">
<div class="water-particles" id="water-particles"></div>
</div>
<div id="instructions">Left Click for Waves | Right Click and Hold for Bubbles</div>
<pre id="ascii-morph-container"></pre>
<div class="morph-cooldown" id="morph-cooldown"></div>
<div id="timer-container">TIME: 3:00</div>
<div id="collection-counter">
  Á∫¢Ëâ≤: 0 | ÁªøËâ≤: 0 | ËìùËâ≤: 0
</div>

<!-- End game screen -->
<div id="end-game-container">
  <div id="end-game-content">
    <div id="ending-title"></div>
    <div class="ending-ascii-art" id="ending-ascii-art"></div>
    <div id="ending-message"></div>
    <button id="restart-button">REPLAY</button>
  </div>
</div>
</div>
<script>
    
document.addEventListener('DOMContentLoaded', function() {

    // Ê∑ªÂä†ËÉåÊôØÈü≥‰πê
    const audioElement = document.createElement('audio');
    audioElement.id = 'background-music';
    // ËÆæÁΩÆÈü≥È¢ëÊ∫ê
    audioElement.src = 'https://cdn.glitch.global/9b9abd46-ae9c-4206-81ff-05f9117caf41/tam-g20loop.ogg?v=1745396377903';
    // ËÆæÁΩÆÂæ™ÁéØÊí≠Êîæ
    audioElement.loop = true;
    // ËÆæÁΩÆÈü≥ÈáèÔºà0.0Âà∞1.0‰πãÈó¥Ôºâ
    audioElement.volume = 0.5; // 50%Èü≥ÈáèÔºåÂèØ‰ª•Ë∞ÉÊï¥
    // Â∞ÜÈü≥È¢ëËÆæ‰∏∫È¢ÑÂä†ËΩΩ
    audioElement.preload = 'auto';
    // Â∞ÜÈü≥È¢ëÂÖÉÁ¥†Ê∑ªÂä†Âà∞È°µÈù¢
    document.body.appendChild(audioElement);

    // Â∞ùËØïËá™Âä®Êí≠Êîæ
    const playPromise = audioElement.play();

    // Â§ÑÁêÜÂèØËÉΩÁöÑÈîôËØØÔºàÊØîÂ¶ÇÊµèËßàÂô®ÈòªÊ≠¢Ëá™Âä®Êí≠ÊîæÔºâ
    if (playPromise !== undefined) {
        playPromise.catch(error => {
            // Â¶ÇÊûúËá™Âä®Êí≠ÊîæË¢´ÈòªÊ≠¢ÔºåÊàë‰ª¨ÂèØ‰ª•Âú®Áî®Êà∑È¶ñÊ¨°ÁÇπÂáªÊó∂Êí≠Êîæ
            console.log('Auto-play was prevented. Will play on user interaction.');
        
            // Ê∑ªÂä†‰∏ÄÊ¨°ÊÄßÁÇπÂáª‰∫ã‰ª∂ÁõëÂê¨Âô®Êù•ÂºÄÂßãÊí≠Êîæ
            document.addEventListener('click', function startAudio() {
                audioElement.play();
                // ÁßªÈô§ÁõëÂê¨Âô®ÔºåËøôÊ†∑Âè™‰ºöÊâßË°å‰∏ÄÊ¨°
                document.removeEventListener('click', startAudio);
            }, { once: true });
        });
    }

    // ÂàõÂª∫Èü≥È¢ëÊéßÂà∂ÊåâÈíÆ
    const audioControl = document.createElement('button');
    audioControl.textContent = 'üîä'; // Èü≥ÈáèÂõæÊ†á
    audioControl.style.position = 'fixed';
    audioControl.style.bottom = '50px';
    audioControl.style.left = '10px';
    audioControl.style.background = 'rgba(60, 90, 120, 0.7)';
    audioControl.style.border = '1px solid rgba(167, 182, 199, 0.3)';
    audioControl.style.borderRadius = '5px';
    audioControl.style.color = '#a7b6c7';
    audioControl.style.padding = '5px 10px';
    audioControl.style.cursor = 'pointer';
    audioControl.style.zIndex = '1000';

    // Èü≥È¢ëÁä∂ÊÄÅ
    let audioMuted = false;

    // ÂàáÊç¢Èü≥È¢ëÁä∂ÊÄÅ
    audioControl.addEventListener('click', function() {
        if (audioMuted) {
            audioElement.volume = 0.5;
            audioControl.textContent = 'üîä';
            audioMuted = false;
        } else {
            audioElement.volume = 0;
            audioControl.textContent = 'üîá';
            audioMuted = true;
        }
    });

    // Ê∑ªÂä†Âà∞È°µÈù¢
    document.body.appendChild(audioControl);

    // ‰øÆÊîπ: Ê∑ªÂä†Ê∏∏ÊàèËÆ°Êó∂Âô®ÂèòÈáè
    let gameStarted = false;
    let timeLeft = 180; // 3ÂàÜÈíü = 180Áßí
    let timerInterval = null;
    const timerContainer = document.getElementById('timer-container');
    
    // ÂêØÂä®ËÆ°Êó∂Âô®ÂáΩÊï∞
    function startTimer() {
    if (gameStarted) return; // Â¶ÇÊûúÂ∑≤ÁªèÂºÄÂßã‰∫ÜÔºåÂ∞±‰∏çÈáçÂ§çÂêØÂä®
    
    gameStarted = true;
    timerInterval = setInterval(function() {
        timeLeft--;
        
        // Êõ¥Êñ∞ËÆ°Êó∂Âô®ÊòæÁ§∫
        const minutes = Math.floor(timeLeft / 60);
        const seconds = timeLeft % 60;
        timerContainer.textContent = `TIME: ${minutes}:${seconds < 10 ? '0' + seconds : seconds}`;
        
        // Êó∂Èó¥Âà∞Êó∂ÁªìÊùüÊ∏∏Êàè
        if (timeLeft <= 0) {
            clearInterval(timerInterval);
            endGame();
        }
    }, 1000);
    
    // 15ÁßíÂêéËß¶ÂèëUFOÔºà‰ªÖÂú®Ê∏∏ÊàèÂºÄÂßãÂêéÔºâ
    setTimeout(function() {
        summonUFO();
    }, 15000);
}
    
    // ÊâæÂà∞endGameÂáΩÊï∞Âπ∂ÊõøÊç¢‰∏∫‰ª•‰∏ã‰ª£Á†Å
    function endGame() {
        const endGameContainer = document.getElementById('end-game-container');
        const endingTitle = document.getElementById('ending-title');
        const endingMessage = document.getElementById('ending-message');
        const endingAsciiArt = document.getElementById('ending-ascii-art');
    
        // ÂÜ≥ÂÆöÁªìÂ±ÄÁ±ªÂûã
        let endingType = "neutral";
    
        // Â¶ÇÊûú‰∏Ä‰∏™ÈÉΩÊ≤°Êî∂ÈõÜÂà∞ÔºåÂàô‰∏∫‰∏≠Á´ãÁªìÂ±Ä
        if (collectedAsciiColors.total === 0) {
            endingType = "neutral";
        } 
        // Âê¶ÂàôÊü•ÁúãÂì™ÁßçÈ¢úËâ≤ÊúÄÂ§ö
        else {
            const maxColor = Math.max(
                collectedAsciiColors.red, 
                collectedAsciiColors.green, 
                collectedAsciiColors.blue
            );
        
            if (maxColor === collectedAsciiColors.red) {
                endingType = "red";
            } else if (maxColor === collectedAsciiColors.green) {
                endingType = "green";
            } else if (maxColor === collectedAsciiColors.blue) {
                endingType = "blue";
            }
        }
    
        // Ê†πÊçÆÁªìÂ±ÄÁ±ªÂûãËÆæÁΩÆÂÜÖÂÆπ
        switch(endingType) {
            case "red":
                endingTitle.textContent = "Archaeological Report: DATA HISTORY";
                endingMessage.textContent = "After extensive analysis, we have concluded that Earth was never a biological civilization but rather an intergalactic USB storage facility.\n" +
                "The surviving structures display modular, grid-like patterns with dense data inscriptions, indicating that these were not cities, but information storage hubs. There is no evidence that Earth inhabitants interacted physically. Instead, they seem to have converted their entire history into code archives, stored in what we now classify as ‚ÄúCODE VAULTS.\n" +
                "\n" +
                "Strangely, Earth‚Äôs final recorded data entry is a repeated system error message: \n" +
                "\n" +
                " * No Storage Space Left. Please Delete Files to Continue.\n" +
                "\n" +
                "There is no evidence that they resolved this issue before their collapse. Our AI model suggests Earth‚Äôs civilization ultimately crashed due to a critical memory overflow and was lost forever.";
                endingAsciiArt.textContent = 
                    "    ,    \n" +
                    "   ,,    \n" +
                    "   ,,,   \n" +
                    "   ,,,   \n" +
                    "   ,,,   \n" +
                    "  ,,,,,  \n" +
                    "  ,,,,,  \n" +
                    " ,,,,,,, \n" +
                    " ,,,,,,, \n" +
                    ",,,,,,,,,\n" +
                    " ^^^^^^^";
                endingAsciiArt.style.color = "rgba(255, 120, 120, 0.9)";
                break;
            
            case "green":
                endingTitle.textContent = "Archaeological Report: BIG BATH";
                endingMessage.textContent = "Recent evidence suggests that Earth was not a traditional civilization but rather a planetary-scale wellness retreat. Surviving structures indicate that Earth‚Äôs inhabitants lived in Floating Pool sanctuaries, where they engaged in daily thermal baths and spiritual relaxation rituals. Their belief system appears to have been centered around the perfect state of flotation, suggesting a philosophy where absolute relaxation was considered the ultimate enlightenment.\n" +
                "\n" +
                "There is no evidence of war or conflict. Instead, social hierarchy was determined by MASSAGE CODE, a classification system based on the depth and frequency of massages received. The ultimate cause of extinction is linked to a phenomenon known as ‚ÄúBIG BATH‚Äù. While initial theories suggest a global flooding event, textual analysis implies that Earth‚Äôs civilization may have simply dissolved into a state of pure relaxation and ceased to exist.\n" +
                "\n" +
                "There is no evidence that they ever experienced stress.";
                endingAsciiArt.textContent = 
                    "    _    \n" +
                    "   / \\   \n" +
                    "  /   \\  \n" +
                    " /     \\ \n" +
                    "/       \\\n" +
                    "----+----\n" +
                    "    |    \n" +
                    "    |    \n" +
                    "    |    \n" +
                    "   /|\\   \n" +
                    "  / | \\  ";
                endingAsciiArt.style.color = "rgba(120, 255, 120, 0.9)";
                break;
            
            case "blue":
                endingTitle.textContent = "Archaeological Report: CLOWNY EMPIRE";
                endingMessage.textContent = "The dominant rulers of Earth appear to have been known as ‚ÄúCLOWNY‚Äù‚Äîa social class characterized by exaggerated facial expressions, bright-colored outfits, and large red noses.\n" +
                "There is no evidence that they governed through violence. Instead, their leadership system seems to have relied on ritualized comedic performances and competitive slipping contests. Earth‚Äôs religious system was centered around PRIMADONNAS (opera singers), suggesting a belief structure that required high-pitched vocal performances as expressions of faith.\n" +
                "\n" +
                "Strangely, Earth‚Äôs technological development was focused almost entirely on logistics and delivery services, suggesting that fast delivery was the primary metric of progress.\n" +
                "\n" +
                "Finally, Earth‚Äôs downfall appears to be tied to an event known as ‚ÄúBIG MAC‚Äù, which our AI correlates to extreme consumerism-induced tectonic collapse. There is no evidence that they foresaw their own extinction, but final records indicate they were still waiting in line for food in their last moments.";
                endingAsciiArt.textContent = 
                    "   ~~~~~   \n" +
                    " ~~~~~~~~~~ \n" +
                    "~~~~~~~~~~~~\n" +
                    "  \\       / \n" +
                    "   \\  o  /  \n" +
                    "    \\   /   \n" +
                    "     \\ /    \n" +
                    "      V     \n" +
                    "     / \\    \n" +
                    "    /   \\   \n" +
                    "   /     \\  ";
                endingAsciiArt.style.color = "rgba(120, 120, 255, 0.9)";
                break;
            
            default: // neutral
                endingTitle.textContent = "Archaeological Report: EXO-ERROR-999";
                endingMessage.textContent = 
                    "The research team attempted to analyze Earth‚Äôs historical data, yet we found no evidence to rejcect the Null Hypothesis.\n" +
                    "\n" +
                    " * No evidence suggests that this civilization followed any logical patterns. No evidence suggests that they underwent a normal societal evolution.\n" +
                    " * No evidence suggests that we should continue our research.\n" +
                    " * The archaeological study has been terminated.\n" +
                    "\n" +
                    "Final Conclusion: Earth may have never existed at all.";
                endingAsciiArt.textContent = 
                    "   _,-=._              /|_/|   \n" +
                    "  /=^_^-+\\           (/o o\\)   \n" +
                    "  \\~\\_.-./            > ^ <    \n" +
                    "   /   \\               /~\\     \n" +
                    "  //|.\\\\\\             //|.\\\\   \n" +
                    " ||,|Y| \\           |Y,|Y|     \n" +
                    " \\\\ |.|/             \\|.|/     \n" +
                    "  \\/\"/                \"/\"      \n";
                endingAsciiArt.style.color = "rgba(167, 182, 199, 0.9)";
                break;
        }
    
        // ÊòæÁ§∫ÁªìÊùüÂ±èÂπï
        endGameContainer.style.display = 'flex';
    
        // Ê∑ªÂä†Âú®ËøôÈáåÔºöÂÅúÊ≠¢UFOÁßªÂä®Âπ∂ÁßªÈô§UFOÂÖÉÁ¥†
        if (window.ufoInterval) {
            clearInterval(window.ufoInterval);
            window.ufoInterval = null;
        }
        document.querySelectorAll('.ufo, .beam').forEach(el => el.remove());
    }
     
    // Âú®ËøôÈáåÊ∑ªÂä†ÈáçÂêØÊåâÈíÆ‰∫ã‰ª∂Â§ÑÁêÜ
    document.getElementById('restart-button').addEventListener('click', function() {
        // ÈáçÁΩÆÊ∏∏ÊàèÁä∂ÊÄÅ
        gameStarted = false;
        timeLeft = 180;
        timerContainer.textContent = "TIME: 3:00";
        
        // ÈáçÁΩÆÊî∂ÈõÜËÆ°Êï∞Âô®
        collectedAsciiColors = {red: 0, green: 0, blue: 0, total: 0};
        updateCollectionCounter();
        
        // ÈöêËóèÁªìÊùüÂ±èÂπï
        document.getElementById('end-game-container').style.display = 'none';
        
        // Ê∏ÖÈô§ÊâÄÊúâASCIIËâ∫ÊúØÂíåÂ≠óÁ¨¶
        document.querySelectorAll('.ascii-art-container, .character-fish').forEach(el => el.remove());
        
        // ÈáçÊñ∞ÂàõÂª∫ÂàùÂßãÂ≠óÁ¨¶
        createInitialCharacters();
    });
    
    // ‰øÆÊîπ: ‰∏∫Èº†Ê†á‰∫ã‰ª∂Ê∑ªÂä†ËÆ°Êó∂Âô®ÂêØÂä®ÂäüËÉΩ
    document.addEventListener('mousedown', function(e) {
        // ÂêØÂä®ËÆ°Êó∂Âô®Ôºà‰ªÖÂú®Á¨¨‰∏ÄÊ¨°ÁÇπÂáªÊó∂ÂêØÂä®Ôºâ
        startTimer();
    
        if (e.button === 2) startBubbleFlood(e.clientX);
        // ÁßªÈô§‰∫ÜËøôÈáåÁöÑsummonUFO()Ë∞ÉÁî®
    });
    document.addEventListener('mouseup', function(e) {
        if (e.button === 2) stopBubbleFlood();
    });

            const gameContainer = document.getElementById('game-container');
            const ocean = document.getElementById('ocean');
            const particlesContainer = document.getElementById('water-particles');
            const asciiMorphContainer = document.getElementById('ascii-morph-container');
            const cooldownIndicator = document.getElementById('morph-cooldown');
            
            // Track character bursts for ASCII art formation
            let recentBursts = [];
            // Âú®ÂÖ®Â±ÄÂèòÈáèÂå∫ÂüüÊ∑ªÂä†
let collectedAsciiColors = {
  red: 0,    // Á∫¢Ëâ≤ÔºàÁ¥¢Âºï0Ôºâ
  green: 0,  // ÁªøËâ≤ÔºàÁ¥¢Âºï1Ôºâ
  blue: 0,   // ËìùËâ≤ÔºàÁ¥¢Âºï2Ôºâ
  total: 0   // ÊÄªÊï∞
};
            // Track active ASCII art instances
            let activeAsciiArts = [];
            
            // Characters to use for character "fish"
            const chars = '+*/\\~#@$%&!?><*+=-{};:.^‚ñö‚ñô‚ñü‚ñå‚ññ‚ñÄ‚ñù‚ñû‚ñó‚ñê‚ñé';
            
            // Cooldown management
            const cooldownManager = {
                lastUsedTime: {
                    waveEffect: 0,
                    glowEffect: 0,
                    asciiMorph: 0
                },
                
                cooldownDuration: {
                    waveEffect: 300, // Reduced for better responsiveness
                    glowEffect: 600, // Reduced for better responsiveness
                    asciiMorph: 3000 // Reduced to 3 seconds cooldown for better game flow
                },
                
                canUseSkill: function(skillName) {
                    const now = Date.now();
                    const lastUsed = this.lastUsedTime[skillName] || 0;
                    const cooldown = this.cooldownDuration[skillName] || 0;
                    
                    return (now - lastUsed) >= cooldown;
                },
                
                useSkill: function(skillName) {
                    this.lastUsedTime[skillName] = Date.now();
                    
                    // Show cooldown indicator if it's the ASCII morph
                    if (skillName === 'asciiMorph') {
                        cooldownIndicator.textContent = 'ASCII Morph Cooldown: ' + 
                            (this.cooldownDuration.asciiMorph / 1000) + 's';
                        cooldownIndicator.classList.add('cooldown-active');
                        
                        setTimeout(() => {
                            cooldownIndicator.classList.remove('cooldown-active');
                        }, this.cooldownDuration.asciiMorph);
                    }
                },
                
                getRemainingCooldown: function(skillName) {
                    const now = Date.now();
                    const lastUsed = this.lastUsedTime[skillName] || 0;
                    const cooldown = this.cooldownDuration[skillName] || 0;
                    return Math.max(0, cooldown - (now - lastUsed));
                }
            };
            
            // ASCII art patterns - exactly 12 patterns
const asciiPatterns = [
    // Fish
    [
        "              ,",
        "             /|      __",
        "            / |   ,-~ /",
        "           Y :|  //  /",
        "           | jj /( .^",
        "           >-\"~\"-v\"",
        "          /       Y",
        "         jo  o    |",
        "        ( ~T~     j",
        "         >._-' _./",
        "        /   \"~\"  |",
        "       Y     _,  |",
        "      /| ;-\"~ _  l",
        "     / l/ ,-\"~    \\",
        "     \\//\\/      .- \\",
        "      Y        /    Y",
        "      l       I     !",
        "      ]\\      _\\    /\"\\",
        "     (\" ~----( ~   Y.  )"
    ],
    // Turtle
    [
        "     \\`.     ___",
        "      \\ \\   / __>0",
        "  /\\  /  |/' / ",
        " /  \\/   `  ,`'--.",
        "/ /(___________)_ \\",
        "|/ //.-.   .-.\\\\ \\ \\",
        "0 // :@ ___ @: \\\\ \\/",
        "  ( o ^(___)^ o ) 0",
        "   \\ \\_______/ /",
        "/\\   '._______.'--.",
        "\\ /|  |<_____>    |",
        " \\ \\__|<_____>____/|__",
        "  \\____<_____>_______/"
    ],
    // Small Jellyfish
    [
        "  ,=\"   \"=.",
        " /  6 6  \\",
        "(    7    )",
        " \\  '--'  /",
        "  \\=...=/",
        " /       \\",
        "(         )",
        " \\_______/",
        "(           )",
        "'.______.'"
    ],
    // Octopus Head
    [
        "    _____     ",
        "  .'     '.   ",
        " /  o   o  \\  ",
        "|           | ",
        "|  \\     /  | ",
        " \\  '---'  /  ",
        "  '._____.'   "
    ],
    // Squid
    [
        "        ____",
        "       o8%8888,",
        "     o88%8888888.",
        "    8'-    -:8888b",
        "   8'         8888",
        "  d8.-=. ,==-.:888b",
        "  >8 `~` :`~' d8888",
        "  88         ,88888",
        "  88b. `-~  ':88888",
        "  888b ~==~ .:88888",
        "  88888o--:':::8888",
        "  `88888| :::' 8888b",
        "  8888^^'       8888b"
    ],
    // School of Fish
    [
        "     _      _      _",
        "  __(.)< __(.)> __(.)=",
        "  \\___)  \\___)  \\___)  ",
        "         _      _      _",
        "      __(.)< __(.)> __(.)=",
        "      \\___)  \\___)  \\___)   ",
        "     _      _      _",
        "  __(.)< __(.)> __(.)=",
        "  \\___)  \\___)  \\___)   "
    ],
    // Buddha
    [
        "                _ooOoo_",
        "               o8888888o",
        "               88\" . \"88",
        "               (| -_- |)",
        "               O\\  =  /O",
        "            ____/`---'\\____",
        "          .'  \\\\|     |//  `.",
        "         /  \\\\|||  :  |||//  \\",
        "        /  _||||| -:- |||||_  \\",
        "        |   | \\\\\\  -  /'| |   |",
        "        | \\_|  `\\`---'//  |_/ |",
        "        \\  .-\\__ `-. -'__/-.  /"
    ],
    // Sailboat
    [
        "                             /",
        "                            /",
        "                           /;",
        "                          //",
        "                         ;/",
        "                       ,//",
        "                   _,-' ;_,,",
        "                _,'-_  ;|,'",
        "            _,-'_,..--. |",
        "    ___   .'-'_)'  ) _)\\|      ___",
        "  ,'\"\"\"`'' _  )   ) _)  ''--'''_,-'",
        "-={-o-  /|    )  _)  ) ; '_,--''"
    ],
    // Lighthouse/Tower
    [
        "     .--------.",
        "    / .------. \\",
        "   / /        \\ \\",
        "   | |        | |",
        "  _| |________| |_",
        ".' |_|        |_| '.",
        "'._____ ____ _____.'",
        "|     .'____'.     |",
        "'.__.'.'    '.'.__.'",
        "'.__  |      |  __.'",
        "|   '.'.____.'.'   |",
        "'.____'.____.'____.'",
        "'.________________.'"
    ],
    // Crab
    [
        "   __     __",
        "  /  \\~~~~/  \\",
        " (    ..     )_",
        "  \\         /  \\",
        "   \\_______/    \\",
        "   (  0   0  )   \\",
        "  ==\\  <Y>  /     \\",
        "    )=====>(      )",
        "   /       \\     /",
        "  /         \\   /",
        " /           \\ /",
        "(             )",
        "(             )"
    ],
    // Seashell
    [
        "   _.-''|''-._",
        " .'  |      |  '.",
        "/    |      |    \\",
        "|    |      |    |",
        "|    |______|    |",
        "|  /''      '\\  |",
        "| |            | |",
        " \\|            |/",
        "  '-------------'"
    ],
    // Whale
    [
        "       .-------------.",
        "      /               \\",
        "     /  .-------.   ,  \\",
        "    |   |       |  /|   |",
        "    |   |       | / |   |",
        "     \\  '-------'   /   /",
        "      \\___________/   /",
        "    ___/           \\___",
        "   /   \\___________/   \\",
        "  /                     \\",
        " /_______________________\\"
    ]
];
            
           // Implement the AsciiMorph library
const AsciiMorph = (function() {
    'use strict';
    
    let element = null;
    let canvasDimensions = {};
    let renderedData = [];
    let framesToAnimate = [];
    let myTimeout = null;
    
    // Utils
    function extend(target, source) {
        for (let key in source) {
            if (!(key in target)) {
                target[key] = source[key];              
            }
        }
        return target;
    }
    
    function repeat(pattern, count) {
        if (count < 1) return '';
        let result = '';
        while (count > 1) {
            if (count & 1) result += pattern;
            count >>= 1, pattern += pattern;
        }
        return result + pattern;
    }
    
    function replaceAt(string, index, character) {
        return string.substr(0, index) + character + string.substr(index+character.length);
    }
    
    // Initialize
    function init(el, canvasSize) {
        element = el;
        canvasDimensions = canvasSize;
    }
    
    // Square out data
    function squareOutData(data) {
        let i;
        let renderDimensions = {
            x: 0,
            y: data.length
        };

        // Calculate centering numbers
        for (i = 0; i < data.length; i++) {
            if (data[i].length > renderDimensions.x) {
                renderDimensions.x = data[i].length;
            }
        }
        
        // Pad out right side of data to square it out
        for (i = 0; i < data.length; i++) {
            if (data[i].length < renderDimensions.x) {
                data[i] = (data[i] + repeat(' ', renderDimensions.x - data[i].length));
            }
        }
        
        let paddings = {
            x: Math.floor((canvasDimensions.x - renderDimensions.x) / 2),
            y: Math.floor((canvasDimensions.y - renderDimensions.y) / 2)
        };
        
        // Left Padding
        for (let i = 0; i < data.length; i++) {
            data[i] = repeat(' ', paddings.x) + data[i] + repeat(' ', paddings.x);
        }
        
        // Pad out the rest of everything
        for (let i = 0; i < canvasDimensions.y; i++) {
            if (i < paddings.y) {
                data.unshift(repeat(' ', canvasDimensions.x));
            } else if (i > (paddings.y + renderDimensions.y)) {
                data.push(repeat(' ', canvasDimensions.x));
            }
        }
        
        return data;
    }
    
    // Crushes the frame data by 1 unit
    function getMorphedFrame(data) {
        let firstInLine, lastInLine = null;
        let found = false;
        
        for (let i = 0; i < data.length; i++) {
            let line = data[i];
            firstInLine = line.search(/\S/);
            
            if (firstInLine === -1) {
                firstInLine = null;
            }
            
            for (let j = 0; j < line.length; j++) {
                if (line[j] != ' ') {
                    lastInLine = j;
                }
            }
            
            if (firstInLine !== null && lastInLine !== null) {
                data = crushLine(data, i, firstInLine, lastInLine);
                found = true;
            }
            
            firstInLine = null;
            lastInLine = null;
        }
        
        if (found) {
            return data;
        } else {
            return false;
        }
    }
    
    // Crush line for morph animation
    function crushLine(data, line, start, end) {
        let centers = {
            x: Math.floor(canvasDimensions.x / 2),
            y: Math.floor(canvasDimensions.y / 2)
        };
        
        let crushDirection = 1;
        if (line > centers.y) {
            crushDirection = -1;
        }
        
        let charA = data[line][start];
        let charB = data[line][end];
        
        data[line] = replaceAt(data[line], start, " ");
        data[line] = replaceAt(data[line], end, " ");

        if (!((end - 1) == (start + 1)) && !(start === end) && !((start + 1) === end)) {
            data[line + crushDirection] = replaceAt(data[line + crushDirection], (start + 1), chars.charAt(Math.floor(Math.random() * chars.length)));
            data[line + crushDirection] = replaceAt(data[line + crushDirection], (end - 1), chars.charAt(Math.floor(Math.random() * chars.length)));
        } else if ((((start === end) || (start + 1) === end)) && ((line + 1) !== centers.y && (line - 1) !== centers.y && line !== centers.y)) {
            data[line + crushDirection] = replaceAt(data[line + crushDirection], start, chars.charAt(Math.floor(Math.random() * chars.length)));
            data[line + crushDirection] = replaceAt(data[line + crushDirection], end, chars.charAt(Math.floor(Math.random() * chars.length)));
        }
        
        return data;
    }
    
    // Render original data
    function render(data) {
        let ourData = squareOutData(data.slice());
        renderSquareData(ourData);
    }
    
    // Render square data
    function renderSquareData(data) {
        element.innerHTML = '';
        for (let i = 0; i < data.length; i++) {
            element.innerHTML = element.innerHTML + data[i] + '\n';
        }
        
        renderedData = data;
    }
    
    // Morph between current and new frame
    function morph(data) {
        clearTimeout(myTimeout);
        let frameData = prepareFrames(data.slice());
        animateFrames(frameData);
    }
    
    // Prepare frames for morphing
    function prepareFrames(data) {
        let deconstructionFrames = [];
        let constructionFrames = [];
        let clonedData = renderedData.slice(0);
        
        // Get deconstruction frames
        for (let i = 0; i < 100; i++) {
            let newData = getMorphedFrame(clonedData);
            if (newData === false) {
                break;
            }
            deconstructionFrames.push(newData.slice(0));
            clonedData = newData;
        }
        
        // Get construction frames
        let squareData = squareOutData(data);
        constructionFrames.unshift(squareData.slice(0));
        
        for (let i = 0; i < 100; i++) {
            let newData = getMorphedFrame(squareData);
            if (newData === false) {
                break;
            }
            constructionFrames.unshift(newData.slice(0));
            squareData = newData;
        }
        
        return deconstructionFrames.concat(constructionFrames);
    }
    
    // Animate frames
    function animateFrames(frameData) {
        framesToAnimate = frameData;
        animateFrame();
    }
    
    // Animate individual frame
    function animateFrame() {
        myTimeout = setTimeout(function() {
            renderSquareData(framesToAnimate[0]);
            framesToAnimate.shift();
            
            if (framesToAnimate.length > 0) {
                animateFrame();
            }
        }, 20);
    }
    
    // Main function
    function main(element, canvasSize) {
        if (!element || !canvasSize) {
            console.log("sorry, I need an element and a canvas size");
            return;   
        }
        
        init(element, canvasSize);
    }
    
    return extend(main, {
        render: render,
        morph: morph
    });
})();

// Initialize AsciiMorph with the container
AsciiMorph(asciiMorphContainer, { x: 51, y: 28 });

// Create water particles
createWaterParticles();

// Set up click events
gameContainer.addEventListener('click', function(e) {
    // ‰øÆÊîπÔºöÊ∑ªÂä†ËÆ°Êó∂Âô®ÂêØÂä®
    startTimer();
    
    if (!cooldownManager.canUseSkill('waveEffect')) {
        return;
    }
    
    cooldownManager.useSkill('waveEffect');
    const rect = ocean.getBoundingClientRect();
    const offsetX = e.clientX - rect.left;
    const offsetY = e.clientY - rect.top;
    createPixelWave(offsetX, offsetY);
    
    // Create character burst after wave
    setTimeout(() => {
        createCharacterBurst(e.clientX, e.clientY - 40);
        pushNearbyCharacters(e.clientX, e.clientY);
    }, 100);
});

// Right-click glow effect
gameContainer.addEventListener('contextmenu', function(e) {
    e.preventDefault(); // Prevent default context menu
    
    // ‰øÆÊîπÔºöÊ∑ªÂä†ËÆ°Êó∂Âô®ÂêØÂä®
    startTimer();
    
    if (!cooldownManager.canUseSkill('glowEffect')) {
        return;
    }
    
    cooldownManager.useSkill('glowEffect');
    const rect2 = ocean.getBoundingClientRect();
    const offsetX2 = e.clientX - rect2.left;
    const offsetY2 = e.clientY - rect2.top;
    createGlowEffect(offsetX2, offsetY2);
});

// Create water particles
function createWaterParticles() {
    for (let i = 0; i < 40; i++) {
        const particle = document.createElement('div');
        particle.classList.add('particle');
        
        // Random size
        const size = 2 + Math.random() * 4;
        particle.style.width = size + 'px';
        particle.style.height = size + 'px';
        
        // Random position
        const posX = Math.random() * 100;
        const posY = Math.random() * 85;
        particle.style.left = posX + '%';
        particle.style.top = posY + '%';
        
        // Random opacity
        particle.style.opacity = 0.1 + Math.random() * 0.3;
        
        particlesContainer.appendChild(particle);
        
        // Animate particle
        animateWaterParticle(particle);
    }
}

// Animate water particle
function animateWaterParticle(particle) {
    // Current position
    let posX = parseFloat(particle.style.left);
    let posY = parseFloat(particle.style.top);
    
    // Random movement
    const moveX = (Math.random() - 0.5) * 0.05;
    const moveY = (Math.random() - 0.5) * 0.02 - 0.01; // Slight upward bias
    
    function updatePosition() {
        // Update position
        posX += moveX;
        posY += moveY;
        
        // Check boundaries
        if (posX < 0) posX = 100;
        if (posX > 100) posX = 0;
        if (posY < 0) posY = 85;
        if (posY > 85) posY = 0;
        
        // Apply position
        particle.style.left = posX + '%';
        particle.style.top = posY + '%';
        
        // Continue animation
        requestAnimationFrame(updatePosition);
    }
    
    // Start animation
    requestAnimationFrame(updatePosition);
}

// Create pixel wave effect for left click
function createPixelWave(x, y) {
    // Wave container
    const waveContainer = document.createElement('div');
    waveContainer.style.position = 'absolute';
    waveContainer.style.left = (x - 60) + 'px';
    waveContainer.style.top = (y - 30) + 'px';
    waveContainer.style.width = '120px';
    waveContainer.style.height = '70px';
    waveContainer.style.pointerEvents = 'none';
    waveContainer.style.zIndex = '50';
    ocean.appendChild(waveContainer);
    
    // Wave colors - more dark and muted for post-apocalyptic mood
    const waveColors = [
        'rgba(180, 195, 210, 0.95)', // Light foam
        'rgba(150, 175, 195, 0.9)',  // Light blue
        'rgba(120, 150, 180, 0.85)', // Medium light blue
        'rgba(90, 125, 160, 0.8)',   // Medium blue
        'rgba(60, 95, 135, 0.75)',   // Deep blue
        'rgba(40, 70, 110, 0.7)'     // Darkest blue
    ];
    
    // Pixel size
    const pixelSize = 4;
    
    // Wave matrix pattern
    const waveMatrix = [
        [0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],
        [0,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,1,1,0],
        [0,0,0,0,0,1,1,2,1,1,1,2,2,2,1,0,0,0,0,1,1,2,1,1,1,1,2,2,1,1],
        [0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,1,0,0,1,2,2,2,2,2,2,2,2,2,2,1],
        [0,0,1,2,2,3,3,3,3,3,3,3,3,3,2,2,1,1,2,3,3,3,3,3,3,3,3,3,2,2],
        [0,1,2,3,3,3,4,4,4,3,3,3,3,3,3,2,2,2,3,4,4,4,4,3,3,3,3,3,3,2],
        [1,2,3,4,4,4,4,4,4,4,4,4,4,4,3,3,3,3,4,4,5,4,4,4,4,4,4,4,3,3],
        [2,3,4,5,5,5,5,5,5,5,5,5,4,4,4,4,4,4,5,5,5,5,5,5,5,5,4,4,4,3],
        [3,4,5,5,6,6,6,6,6,6,6,5,5,5,5,5,5,5,6,6,6,6,6,6,6,5,5,5,5,4],
        [4,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,5,5],
        [5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,5],
        [6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6]
    ];
    
    // Create pixels by wave matrix
    for (let y = 0; y < waveMatrix.length; y++) {
        for (let x = 0; x < waveMatrix[y].length; x++) {
            const colorIndex = waveMatrix[y][x];
            if (colorIndex > 0) {
                // Create pixel element
                const pixel = document.createElement('div');
                pixel.style.position = 'absolute';
                pixel.style.width = pixelSize + 'px';
                pixel.style.height = pixelSize + 'px';
                pixel.style.backgroundColor = waveColors[colorIndex - 1];
                
                // Position
                pixel.style.left = (x * pixelSize) + 'px';
                pixel.style.top = (y * pixelSize) + 'px';
                
                // Add to container
                waveContainer.appendChild(pixel);
                
                // Add animation
                if (y < 4) {
                    // Wave peak
                    pixel.style.animation = `wavePeakFloat ${0.8 + Math.random() * 0.4}s ${x * 0.02}s cubic-bezier(0.25, 0.1, 0.25, 1) forwards`;
                } else if (y < 8) {
                    // Wave middle
                    pixel.style.animation = `waveRipple ${0.7 + Math.random() * 0.3}s ${x * 0.02}s cubic-bezier(0.25, 0.1, 0.25, 1) forwards`;
                } else {
                    // Wave base
                    pixel.style.animation = `waveBase ${0.6 + Math.random() * 0.3}s ${x * 0.02}s cubic-bezier(0.25, 0.1, 0.25, 1) forwards`;
                }
            }
        }
    }
    
    // Add splash droplets
    for (let i = 0; i < 10; i++) {
        setTimeout(() => {
            const splash = document.createElement('div');
            splash.style.position = 'absolute';
            
            // Droplet size
            const dropSize = 1 + Math.random() * 2;
            splash.style.width = dropSize + 'px';
            splash.style.height = dropSize + 'px';
            
            // Droplet color
            const colorIdx = Math.floor(Math.random() * 2);
            splash.style.backgroundColor = waveColors[colorIdx];
            splash.style.borderRadius = '50%';
            
            // Droplet position
            const startX = 30 + Math.random() * 60;
            const startY = Math.random() * 10;
            splash.style.left = startX + 'px';
            splash.style.top = startY + 'px';
            
            // Animation
            splash.style.animation = `waveSplash ${0.5 + Math.random() * 0.5}s ease-out forwards`;
            
            waveContainer.appendChild(splash);
        }, i * 40);
    }
    
    // Cleanup
    setTimeout(() => {
        waveContainer.remove();
    }, 2000);
}

// Create ripple effect for right click
function createGlowEffect(x, y) {
    // Create multiple ripple circles
    for (let i = 0; i < 3; i++) {
        setTimeout(() => {
            // Create ripple element
            const ripple = document.createElement('div');
            ripple.className = 'ripple-effect';
            
            // Size slightly different for each circle
            const size = 80 + (i * 40);
            ripple.style.width = size + 'px';
            ripple.style.height = size + 'px';
            
            // Center at click position
            ripple.style.left = (x - size/2) + 'px';
            ripple.style.top = (y - size/2) + 'px';
            
            // Add to ocean
            ocean.appendChild(ripple);
            
            createRisingBubbles(x);

            // Remove after animation
            setTimeout(() => {
                ripple.remove();
            }, 1500);
        }, i * 200); // Staggered timing for concentric ripples
    }
    
    // Create character burst with different animation
    setTimeout(() => {
        createGlowCharacters(x, y);
    }, 300);
}
// Create characters from ripple effect
function createGlowCharacters(x, y) {
    // Container for characters
    const charContainer = document.createElement('div');
    charContainer.className = 'character-burst-container';
    charContainer.style.left = (x - 60) + 'px';
    charContainer.style.top = (y - 60) + 'px';
    charContainer.style.width = '120px';
    charContainer.style.height = '120px';
    ocean.appendChild(charContainer);
    
    // Create fewer characters for more subtle effect
    const charCount = 8 + Math.floor(Math.random() * 7);
    
    for (let i = 0; i < charCount; i++) {
        // Create character element
        const charElem = document.createElement('div');
        charElem.className = 'character-fish';
        
        // Random character
        charElem.textContent = chars.charAt(Math.floor(Math.random() * chars.length));
        
        // Position in container
        charElem.style.left = '60px';
        charElem.style.top = '60px';
        
        // Style
        charElem.style.fontSize = (10 + Math.floor(Math.random() * 6)) + 'px';
        charElem.style.color = 'rgba(255, 255, 255, 0.9)';
        charElem.style.textShadow = '0 0 5px rgba(255, 255, 255, 0.8)';
        
        // Add to container
        charContainer.appendChild(charElem);
        
        // Add animation
        const angle = Math.random() * Math.PI * 2;
        const distance = 20 + Math.random() * 30;
        const delay = Math.random() * 0.3;
        
        charElem.style.animation = `charFromRipple 1s ${delay}s forwards`;
        
        // Final position
        setTimeout(() => {
            const finalX = 60 + Math.cos(angle) * distance;
            const finalY = 60 + Math.sin(angle) * distance;
            charElem.style.transform = `translate(${finalX - 60}px, ${finalY - 60}px) rotate(360deg)`;
            
            // Fade from white to blue
            charElem.style.transition = 'color 1s, text-shadow 1s';
            charElem.style.color = 'rgba(150, 200, 255, 0.8)';
            charElem.style.textShadow = '0 0 5px rgba(100, 150, 255, 0.6)';
            
            // Animate after burst
            setTimeout(() => {
                animateCharacterFish(charElem);
            }, 1000);
        }, (delay + 1) * 1000);
    }
    
    // Track for ASCII formation
    trackCharacterBurst(x, y);
}

// Create character burst
function createCharacterBurst(x, y) {
    // Container
    const burstContainer = document.createElement('div');
    burstContainer.className = 'character-burst-container';
    burstContainer.style.position = 'absolute';
    burstContainer.style.left = (x - 60) + 'px';
    burstContainer.style.top = (y - 60) + 'px';
    burstContainer.style.width = '120px';
    burstContainer.style.height = '120px';
    ocean.appendChild(burstContainer);
    
    // Create characters
    const charCount = 12 + Math.floor(Math.random() * 8);
    
    // Colors
    const colors = [
        'rgba(167, 182, 199, 0.9)',
        'rgba(147, 162, 179, 0.9)',
        'rgba(127, 142, 159, 0.9)',
        'rgba(107, 122, 139, 0.9)',
        'rgba(87, 102, 119, 0.9)'
    ];
    
    for (let i = 0; i < charCount; i++) {
        const charElem = document.createElement('div');
        charElem.className = 'character-fish';
        
        // Random character
        charElem.textContent = chars.charAt(Math.floor(Math.random() * chars.length));
        
        // Style
        charElem.style.position = 'absolute';
        charElem.style.fontSize = (12 + Math.floor(Math.random() * 6)) + 'px';
        charElem.style.color = colors[Math.floor(Math.random() * colors.length)];
        charElem.style.textShadow = '0 0 5px rgba(100, 150, 200, 0.5)';
        
        // Initial position
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * 10;
        charElem.style.left = (60 + Math.cos(angle) * distance) + 'px';
        charElem.style.top = (60 + Math.sin(angle) * distance) + 'px';
        
        // Add to container
        burstContainer.appendChild(charElem);
        
        // Animate
        animateCharacter(charElem, i);
    }
    
    // Track for ASCII formation
    trackCharacterBurst(x, y);
    
    return burstContainer;
}

// Track character bursts for ASCII art formation with significantly improved sensitivity
function trackCharacterBurst(x, y) {
    const timestamp = Date.now();
    recentBursts.push({ x, y, timestamp });
    
    // Keep only recent bursts (last 5 seconds - shorter timeframe for better responsiveness)
    recentBursts = recentBursts.filter(b => timestamp - b.timestamp < 5000);
    
    // Check for cluster formation - MUCH IMPROVED SENSITIVITY
    checkForClusterFormation();
    
    // Visualize clicks with subtle glow to give feedback
    createClickFeedback(x, y);
}

// Add visual feedback for clicks to improve user agency
function createClickFeedback(x, y) {
    const feedback = document.createElement('div');
    feedback.style.position = 'absolute';
    feedback.style.left = (x - 15) + 'px';
    feedback.style.top = (y - 15) + 'px';
    feedback.style.width = '30px';
    feedback.style.height = '30px';
    feedback.style.borderRadius = '50%';
    feedback.style.background = 'radial-gradient(circle, rgba(167, 182, 199, 0.3) 0%, rgba(167, 182, 199, 0) 70%)';
    feedback.style.zIndex = '40';
    feedback.style.pointerEvents = 'none';
    
    // Animate
    feedback.style.animation = 'rippleExpand 0.8s cubic-bezier(0.1, 0.5, 0.1, 1) forwards';
    
    // Add to ocean
    ocean.appendChild(feedback);
    
    // Remove after animation
    setTimeout(() => {
        if (feedback.parentNode) {
            feedback.parentNode.removeChild(feedback);
        }
    }, 800);
}

// Significantly improved cluster detection function
function checkForClusterFormation() {
    // Only check if ASCII morph is not on cooldown
    if (!cooldownManager.canUseSkill('asciiMorph')) {
        return;
    }
    
    const timestamp = Date.now();
    
    // Create a heatmap of character density with smaller grid for better precision
    const gridSize = 80; // Reduced grid size for better detection
    const heatmap = {};
    
    // Fill the heatmap
    for (let i = 0; i < recentBursts.length; i++) {
        const burst = recentBursts[i];
        
        // Calculate grid position
        const gridX = Math.floor(burst.x / gridSize);
        const gridY = Math.floor(burst.y / gridSize);
        
        // Check cells in a 3x3 area to create smoother clusters
        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                const key = (gridX+dx) + ',' + (gridY+dy);
                
                // Distance from center affects weight
                const cellWeight = (dx === 0 && dy === 0) ? 1 : 0.5;
                
                // Add to heatmap with time decay (newer bursts count more)
                // Much stronger time weighting: recent clicks count much more
                const age = (timestamp - burst.timestamp) / 5000; // 0 to 1, shorter timeframe
                const weight = Math.max(0, 1 - age) * cellWeight; // Newer bursts have more weight
                
                if (!heatmap[key]) {
                    heatmap[key] = { count: 0, x: 0, y: 0, recentClicks: 0 };
                }
                
                heatmap[key].count += weight;
                heatmap[key].x += burst.x * weight;
                heatmap[key].y += burst.y * weight;
                
                // Count very recent clicks separately (last 2 seconds)
                if (timestamp - burst.timestamp < 2000) {
                    heatmap[key].recentClicks += 1;
                }
            }
        }
    }
    
   // Find the hottest spot with priority for recent activity
let maxScore = 0;
let hotspot = null;

for (const key in heatmap) {
    // Calculate score with priority to recent activity
    const recentClickBonus = heatmap[key].recentClicks * 1.5; // Bonus for recent clicks
    const score = heatmap[key].count + recentClickBonus;
    
    // Direct pattern detection: consecutive clicks in same area
    const hasConsecutiveClicks = heatmap[key].recentClicks >= 3; // 3+ clicks in 2 seconds
    
    // If we detect consecutive clicks pattern, immediately trigger
    if (hasConsecutiveClicks) {
        hotspot = heatmap[key];
        console.log("Consecutive clicks detected! Triggering ASCII art");
        break;
    }
    
    if (score > maxScore) {
        maxScore = score;
        hotspot = heatmap[key];
    }
}

// Significantly reduced threshold and added patterns detection
// If we have a dense enough cluster or pattern detected, trigger ASCII art
if (hotspot && (maxScore > 4 || hotspot.recentClicks >= 3)) {
    // Calculate the center of the hotspot
    const centerX = hotspot.x / hotspot.count || 
                   recentBursts[recentBursts.length-1].x; // Fallback to last click
    const centerY = hotspot.y / hotspot.count || 
                   recentBursts[recentBursts.length-1].y;
    
    console.log("Found cluster with score " + maxScore + " - triggering ASCII art");
    triggerAsciiMorph(centerX, centerY);
    
    // Use cooldown skill
    cooldownManager.useSkill('asciiMorph');
    
    // Clear recent bursts in this area to prevent immediate re-triggering
    const clearRadius = 100;
    recentBursts = recentBursts.filter(burst => {
        const dx = burst.x - centerX;
        const dy = burst.y - centerY;
        const distance = Math.sqrt(dx*dx + dy*dy);
        return distance > clearRadius;
    });
}
}

// Ëß¶ÂèëASCIIÂΩ¢ÊÄÅÂèòÂåñÂπ∂‰ΩøÁî®ÈöèÊú∫È¢úËâ≤
function triggerAsciiMorph(x, y) {
    // ÈÄâÊã©‰∏Ä‰∏™ÈöèÊú∫ASCIIÂõæÊ°à
    const pattern = asciiPatterns[Math.floor(Math.random() * asciiPatterns.length)];
    
    // È¢úËâ≤ÈÄâÈ°π
    const colors = [
        'rgba(255, 120, 120, 0.9)', // Á∫¢Ëâ≤
        'rgba(120, 255, 120, 0.9)', // ÁªøËâ≤
        'rgba(120, 120, 255, 0.9)'  // ËìùËâ≤
    ];
    
    // ÈöèÊú∫ÈÄâÊã©‰∏ÄÁßçÈ¢úËâ≤
    const randomColorIndex = Math.floor(Math.random() * colors.length);
    const randomColor = colors[randomColorIndex];
    const shadowColor = colors[randomColorIndex].replace('0.9', '0.5');
    
    // Ëé∑ÂèñÊ≠§Âå∫ÂüüÁöÑÂ≠óÁ¨¶ËøõË°åÂä®ÁîªÂ§ÑÁêÜ
    const radius = 150;
    const chars = document.querySelectorAll('.character-fish');
    const charsToAnimate = [];
    
    chars.forEach(charElem => {
        const rect = charElem.getBoundingClientRect();
        const charX = rect.left + rect.width / 2;
        const charY = rect.top + rect.height / 2;
        
        const dx = charX - x;
        const dy = charY - y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < radius) {
            charsToAnimate.push({
                element: charElem,
                x: charX,
                y: charY,
                distance: distance
            });
        }
    });
    
    // Â¶ÇÊûúÊúâË∂≥Â§üÁöÑÂ≠óÁ¨¶Êù•Âä®ÁîªÂ§ÑÁêÜ
    if (charsToAnimate.length > 5) {
        // ÂÆö‰ΩçmorphÂÆπÂô®
        asciiMorphContainer.style.display = 'block';
        asciiMorphContainer.style.left = (x - 100) + 'px';
        asciiMorphContainer.style.top = (y - 100) + 'px';
        
        // ËÆæÁΩÆÈöèÊú∫È¢úËâ≤
        asciiMorphContainer.style.color = randomColor;
        asciiMorphContainer.style.textShadow = `0 0 5px ${shadowColor}`;
        
        // ËÆ©Â≠óÁ¨¶Âêë‰∏≠ÂøÉÊ±áËÅö
        charsToAnimate.forEach(char => {
            // Ê∑ªÂä†ÂèëÂÖâÂä®Áîª
            char.element.style.animation = 'charGlow 0.5s ease-in-out';
            
            // Âêë‰∏≠ÂøÉÁßªÂä®
            setTimeout(() => {
                const dx = x - char.x;
                const dy = y - char.y;
                char.element.style.transition = 'transform 0.5s cubic-bezier(0.2, 0.8, 0.3, 1.0)';
                char.element.style.transform = `translate(${dx}px, ${dy}px) scale(0.1)`;
                
                // Âä®ÁîªÂêéÁßªÈô§
                setTimeout(() => {
                    if (char.element.parentNode) {
                        char.element.parentNode.removeChild(char.element);
                    }
                }, 500);
            }, Math.random() * 300);
        });
        
        // Ê∏≤ÊüìÂàùÂßãÁ©∫ÂÆπÂô®
        AsciiMorph.render(['']);
        
        // ÂèòÂΩ¢‰∏∫ASCIIÂõæÊ°à
        setTimeout(() => {
            AsciiMorph.morph(pattern);
            
            // ÂèòÂΩ¢Âä®ÁîªÂÆåÊàêÂêéÂàõÂª∫ASCIIËâ∫ÊúØÂÖÉÁ¥†
            setTimeout(() => {
                // ÂàõÂª∫ÊúÄÁªàÂ∏¶È¢úËâ≤ÁöÑASCIIËâ∫ÊúØÂÖÉÁ¥†
                createAsciiArt(pattern, x, y);
                
                // ÈöêËóèmorphÂÆπÂô®
                asciiMorphContainer.style.display = 'none';
            }, 1000); // Á≠âÂæÖÂèòÂΩ¢Âä®ÁîªÂÆåÊàê
        }, 700); // Âú®Â≠óÁ¨¶ÂºÄÂßãÊ±áËÅöÂêéÂºÄÂßã
    }
}

// ÂàõÂª∫ASCIIËâ∫ÊúØÂÖÉÁ¥†
function createAsciiArt(pattern, x, y) {
    // ÂàõÂª∫ÈöèÊú∫È¢úËâ≤ - Á∫¢„ÄÅÁªø„ÄÅËìù‰∏âÁßçÈ¢úËâ≤
    const colors = [
        'rgba(255, 120, 120, 0.9)', // Á∫¢Ëâ≤
        'rgba(120, 255, 120, 0.9)', // ÁªøËâ≤
        'rgba(120, 120, 255, 0.9)'  // ËìùËâ≤
    ];
    
    // ÈöèÊú∫ÈÄâÊã©‰∏ÄÁßçÈ¢úËâ≤
    const randomColorIndex = Math.floor(Math.random() * colors.length);
    const randomColor = colors[randomColorIndex];
    
    // ‰∏∫Èò¥ÂΩ±ÂàõÂª∫Á®çÊöóÁöÑÈ¢úËâ≤ÁâàÊú¨
    const shadowColor = colors[randomColorIndex].replace('0.9', '0.5');
    
    // ÂàõÂª∫ASCIIËâ∫ÊúØÂÆπÂô®
    const art = document.createElement('div');
    art.className = 'ascii-art-container';
    art.style.position = 'absolute';
    art.style.left = (x - 75) + 'px';
    art.style.top = (y - 75) + 'px';
    art.style.fontSize = '8px';
    art.style.opacity = '0';
    art.style.transform = 'scale(0.5)';
    art.style.transition = 'opacity 1s, transform 1s';
    art.style.whiteSpace = 'pre';
    art.textContent = pattern.join('\n');
    
    // Â∫îÁî®ÈöèÊú∫È¢úËâ≤
    art.style.color = randomColor;
    art.style.textShadow = `0 0 5px ${shadowColor}`;
    
    // ËÆæÁΩÆIDÂíåÊ∑ªÂä†Êï∞ÊçÆÂ±ûÊÄß
    const artId = 'ascii-art-' + Date.now();
    art.id = artId;
    art.dataset.lastTransform = Date.now();
    art.dataset.characterCollisions = '0';
    art.dataset.colorIndex = randomColorIndex; // Â≠òÂÇ®È¢úËâ≤Á¥¢Âºï‰ª•‰æøÂêéÁª≠‰ΩøÁî®
    
    // Ê∑ªÂä†Âà∞ocean
    ocean.appendChild(art);
    
    // Ê∑ªÂä†Âà∞Ê¥ªÂä®ASCIIËâ∫ÊúØË∑üË∏™
    activeAsciiArts.push({
        id: artId,
        element: art,
        pattern: pattern,
        x: x,
        y: y,
        colorIndex: randomColorIndex, // Â≠òÂÇ®È¢úËâ≤Á¥¢Âºï
        createdAt: Date.now(),
        lastTransform: Date.now(),
        characterCollisions: 0
    });
    
    // Ê∑°ÂÖ•
    setTimeout(() => {
        art.style.opacity = '0.9';
        art.style.transform = 'scale(1)';
    }, 50);
    
    // Âä®ÁîªASCIIËâ∫ÊúØ
    setTimeout(() => {
        animateAsciiArt(art);
    }, 1000);
}

// Animate ASCII art
function animateAsciiArt(artElement) {
    // Get starting position
    const startX = parseFloat(artElement.style.left);
    const startY = parseFloat(artElement.style.top);
    
    // Movement properties
    const duration = 30000 + Math.random() * 20000; // 30-50 seconds
    const amplitude = 15 + Math.random() * 20; // Wave height
    const speedX = 0.05 + Math.random() * 0.1; // Horizontal movement speed
    
    // Start time
    const startTime = Date.now();
    
    // Animation function
    function update() {
        // Skip if element was removed
        if (!artElement.parentNode) return;
        
        const elapsed = Date.now() - startTime;
        const progress = elapsed / duration;
        
        if (progress < 1) {
            // Calculate new position
            const newX = startX + (progress * speedX * window.innerWidth);
            const sinValue = Math.sin(progress * Math.PI * 2);
            const newY = startY + (sinValue * amplitude);
            
            // Apply position
            artElement.style.left = newX + 'px';
            artElement.style.top = newY + 'px';
            
            // Check for collisions with character fish
            checkAsciiCharCollisions(artElement);
            
            // Continue animation
            requestAnimationFrame(update);
        } else {
            // Check if this is still in active arts list
            removeFromActiveArts(artElement.id);
            
            // Remove when animation is done
            artElement.remove();
        }
    }
    
    // Start animation
    requestAnimationFrame(update);
}

// Check ASCII art collisions with characters
function checkAsciiCharCollisions(artElement) {
    // Get element from active list
    const artData = activeAsciiArts.find(art => art.id === artElement.id);
    if (!artData) return;
    
    // Throttle collision checks a bit for performance
    const now = Date.now();
    if (now - artData.lastCollisionCheck < 200) return;
    artData.lastCollisionCheck = now;
    
    const artRect = artElement.getBoundingClientRect();
    const charFishes = document.querySelectorAll('.character-fish');
    
    charFishes.forEach(fish => {
        const fishRect = fish.getBoundingClientRect();
        
        // Simple collision detection
        if (!(fishRect.right < artRect.left || 
            fishRect.left > artRect.right || 
            fishRect.bottom < artRect.top || 
            fishRect.top > artRect.bottom)) {
            
            // Remove the fish
            if (fish.parentNode) {
                // Add glow animation before removing
                fish.style.animation = 'charGlow 0.5s ease-out';
                fish.style.opacity = '0';
                
                setTimeout(() => {
                    if (fish.parentNode) {
                        fish.parentNode.removeChild(fish);
                    }
                }, 500);
            }
            
            // Increment collision counter
            artData.characterCollisions++;
            
            // Transform ASCII art if enough collisions and not on cooldown
            if (artData.characterCollisions >= 5 && // Further reduced threshold to make transformation easier
                (now - artData.lastTransform) > 5000) { // Reduced to 5 seconds for better game flow
                
                artData.lastTransform = now;
                transformAsciiArt(artElement);
            }
        }
    });
}

// Remove from active ASCII arts tracking
function removeFromActiveArts(id) {
    const index = activeAsciiArts.findIndex(art => art.id === id);
    if (index !== -1) {
        activeAsciiArts.splice(index, 1);
    }
}
// Transform ASCIIËâ∫ÊúØ‰∏∫Êñ∞ÂõæÊ°àÂπ∂‰ΩøÁî®ÈöèÊú∫È¢úËâ≤
function transformAsciiArt(artElement) {
    // Ëé∑Âèñ‰ΩçÁΩÆ
    const x = parseFloat(artElement.style.left) + artElement.offsetWidth / 2;
    const y = parseFloat(artElement.style.top) + artElement.offsetHeight / 2;
    
    // Ëé∑ÂèñÂΩìÂâçÂõæÊ°àÁ¥¢Âºï
    const currentText = artElement.textContent;
    
    // ÈÄâÊã©‰∏Ä‰∏™‰∏çÂêåÁöÑÂõæÊ°à
    let newPatternIndex;
    do {
        newPatternIndex = Math.floor(Math.random() * asciiPatterns.length);
    } while (asciiPatterns[newPatternIndex].join('\n') === currentText);
    
    // È¢úËâ≤ÈÄâÈ°π
    const colors = [
        'rgba(255, 120, 120, 0.9)', // Á∫¢Ëâ≤
        'rgba(120, 255, 120, 0.9)', // ÁªøËâ≤
        'rgba(120, 120, 255, 0.9)'  // ËìùËâ≤
    ];
    
    // ÈöèÊú∫ÈÄâÊã©Êñ∞È¢úËâ≤
    const randomColorIndex = Math.floor(Math.random() * colors.length);
    const randomColor = colors[randomColorIndex];
    const shadowColor = colors[randomColorIndex].replace('0.9', '0.5');
    
    // Â∞ÜmorphÂÆπÂô®ÂÆö‰ΩçÂú®Ëâ∫ÊúØ‰ΩçÁΩÆ
    asciiMorphContainer.style.display = 'block';
    asciiMorphContainer.style.left = (x - 100) + 'px';
    asciiMorphContainer.style.top = (y - 100) + 'px';
    
    // Â∫îÁî®Êñ∞ÁöÑÈöèÊú∫È¢úËâ≤Âà∞morphÂÆπÂô®
    asciiMorphContainer.style.color = randomColor;
    asciiMorphContainer.style.textShadow = `0 0 5px ${shadowColor}`;
    
    // Âú®ASCIIËâ∫ÊúØÂë®Âõ¥ÂàõÂª∫Á≤íÂ≠êÊïàÊûú
    createTransformationParticles(x, y, randomColor, shadowColor);
    
    // Ê∑°Âá∫ÂéüÂßãËâ∫ÊúØ
    artElement.style.transition = 'opacity 0.5s';
    artElement.style.opacity = '0';
    
    setTimeout(() => {
        // ÁßªÈô§ÂéüÂßãASCIIËâ∫ÊúØ
        if (artElement.parentNode) {
            artElement.parentNode.removeChild(artElement);
            removeFromActiveArts(artElement.id);
        }
        
        // ÂèòÂΩ¢Âà∞Êñ∞ÂõæÊ°à
        AsciiMorph.morph(asciiPatterns[newPatternIndex]);
        
        // ÂèòÂΩ¢ÂÆåÊàêÂêéÔºåÂàõÂª∫Êñ∞ÁöÑËâ∫ÊúØ
        setTimeout(() => {
            // ‰ΩøÁî®Âêå‰∏ÄÈöèÊú∫È¢úËâ≤ÂàõÂª∫Êñ∞Ëâ∫ÊúØ
            const art = document.createElement('div');
            art.className = 'ascii-art-container';
            art.style.position = 'absolute';
            art.style.left = (x - 75) + 'px';
            art.style.top = (y - 75) + 'px';
            art.style.fontSize = '8px';
            art.style.opacity = '0';
            art.style.color = randomColor;
            art.style.textShadow = `0 0 5px ${shadowColor}`;
            art.style.transform = 'scale(0.5)';
            art.style.transition = 'opacity 1s, transform 1s';
            art.style.whiteSpace = 'pre';
            art.textContent = asciiPatterns[newPatternIndex].join('\n');
            
            // ËÆæÁΩÆIDÂíåÊ∑ªÂä†Êï∞ÊçÆÂ±ûÊÄß
            const artId = 'ascii-art-' + Date.now();
            art.id = artId;
            art.dataset.lastTransform = Date.now();
            art.dataset.characterCollisions = '0';
            art.dataset.colorIndex = randomColorIndex;
            
            // Ê∑ªÂä†Âà∞ocean
            ocean.appendChild(art);
            
            // Ê∑ªÂä†Âà∞Ê¥ªÂä®ASCIIËâ∫ÊúØË∑üË∏™
            activeAsciiArts.push({
                id: artId,
                element: art,
                pattern: asciiPatterns[newPatternIndex],
                x: x,
                y: y,
                colorIndex: randomColorIndex,
                createdAt: Date.now(),
                lastTransform: Date.now(),
                characterCollisions: 0
            });
            
            // Ê∑°ÂÖ•
            setTimeout(() => {
                art.style.opacity = '0.9';
                art.style.transform = 'scale(1)';
            }, 50);
            
            // Âä®ÁîªASCIIËâ∫ÊúØ
            setTimeout(() => {
                animateAsciiArt(art);
            }, 1000);
            
            // ÈöêËóèmorphÂÆπÂô®
            asciiMorphContainer.style.display = 'none';
        }, 1000);
    }, 500);
}

// ÂàõÂª∫ÂèòÂΩ¢Á≤íÂ≠êÊïàÊûúÔºå‰ΩøÁî®ÊåáÂÆöÈ¢úËâ≤
function createTransformationParticles(x, y, color = 'rgba(200, 220, 255, 0.9)', shadowColor = 'rgba(150, 200, 255, 0.8)') {
    const particleCount = 30;
    
    for (let i = 0; i < particleCount; i++) {
        // ÂàõÂª∫Á≤íÂ≠ê
        const particle = document.createElement('div');
        particle.className = 'character-fish';
        particle.textContent = chars.charAt(Math.floor(Math.random() * chars.length));
        particle.style.position = 'absolute';
        particle.style.left = x + 'px';
        particle.style.top = y + 'px';
        particle.style.fontSize = (10 + Math.random() * 8) + 'px';
        particle.style.color = color;
        particle.style.textShadow = `0 0 8px ${shadowColor}`;
        particle.style.zIndex = '250';
        
        // Ê∑ªÂä†Âà∞ocean
        ocean.appendChild(particle);
        
        // ÂêëÂ§ñÂä®ÁîªÁ≤íÂ≠ê
        const angle = Math.random() * Math.PI * 2;
        const distance = 30 + Math.random() * 70;
        const duration = 500 + Math.random() * 500;
        
        particle.style.transition = `transform ${duration}ms cubic-bezier(0.2, 0.8, 0.3, 1.0), opacity ${duration}ms`;
        
        setTimeout(() => {
            const destX = Math.cos(angle) * distance;
            const destY = Math.sin(angle) * distance;
            
            particle.style.transform = `translate(${destX}px, ${destY}px) rotate(${Math.random() * 360}deg)`;
            particle.style.opacity = '0';
        }, 10);
        
        // Âä®ÁîªÂêéÁßªÈô§
        setTimeout(() => {
            if (particle.parentNode) {
                particle.parentNode.removeChild(particle);
            }
        }, duration + 100);
    }
}

// Animate individual character
function animateCharacter(charElem, index) {
    // Random direction
    const angle = Math.random() * Math.PI * 2;
    const speed = 50 + Math.random() * 50; // pixels per second
    const dirX = Math.cos(angle) * speed;
    const dirY = Math.sin(angle) * speed;
    
    // Start position
    const startX = parseFloat(charElem.style.left);
    const startY = parseFloat(charElem.style.top);
    
    // Start time
    const startTime = Date.now();
    const duration = 5000 + Math.random() * 5000; // 5-10 seconds
    
    // Animation function
    function update() {
        const elapsed = Date.now() - startTime;
        const progress = elapsed / duration;
        
        if (progress < 1 && charElem.parentNode) {
            // Calculate new position
            const newX = startX + dirX * progress;
            const newY = startY + dirY * progress;
            
            // Add sine wave movement
            const waveAmplitude = 10;
            const waveFrequency = 4 * Math.PI;
            const waveOffset = Math.sin(progress * waveFrequency) * waveAmplitude;
            
            // Apply position with wave offset perpendicular to movement
            const perpX = -dirY / speed;
            const perpY = dirX / speed;
            
            charElem.style.left = (newX + perpX * waveOffset) + 'px';
            charElem.style.top = (newY + perpY * waveOffset) + 'px';
            
            // Fade out near the end
            if (progress > 0.7) {
                charElem.style.opacity = 1 - ((progress - 0.7) / 0.3);
            }
            
            // Continue animation
            requestAnimationFrame(update);
        } else if (charElem.parentNode) {
            // Remove when animation is done
            charElem.parentNode.removeChild(charElem);
        }
    }
    
    // Start animation
    requestAnimationFrame(update);
}

// Animate a character fish with continuous movement
function animateCharacterFish(charElem) {
    // Get current position relative to container
    const rect = charElem.getBoundingClientRect();
    const containerRect = ocean.getBoundingClientRect();
    
    const left = rect.left - containerRect.left;
    const top = rect.top - containerRect.top;
    
    // Set absolute position
    charElem.style.position = 'absolute';
    charElem.style.left = left + 'px';
    charElem.style.top = top + 'px';
    
    // Remove from original container and add to ocean
    if (charElem.parentNode !== ocean) {
        charElem.parentNode.removeChild(charElem);
        ocean.appendChild(charElem);
    }
    
    // Movement properties
    const duration = 20000 + Math.random() * 20000; // 20-40 seconds
    const amplitude = 20 + Math.random() * 30; // Wave height
    const speedX = 0.2 + Math.random() * 0.3; // Horizontal speed
    
    // Start time
    const startTime = Date.now();
    
    // Animation function
    function update() {
        const elapsed = Date.now() - startTime;
        const progress = elapsed / duration;
        
        if (progress < 1 && charElem.parentNode) {
            // Calculate new position
            const newX = left + (progress * speedX * window.innerWidth);
            const sinValue = Math.sin(progress * Math.PI * 4);
            const newY = top + (sinValue * amplitude);
            
            // Apply position
            charElem.style.left = newX + 'px';
            charElem.style.top = newY + 'px';
            
            // Continue animation
            requestAnimationFrame(update);
        } else if (charElem.parentNode) {
            // Remove when animation is done
            charElem.parentNode.removeChild(charElem);
        }
    }
    
    // Start animation
    requestAnimationFrame(update);
}
// Push nearby characters when wave is created
function pushNearbyCharacters(x, y) {
    // Get all character elements
    const charElements = document.querySelectorAll('.character-fish');
    
    // Effect radius
    const radius = 150;
    
    // Check each character
    charElements.forEach(charElem => {
        // Get character position
        const rect = charElem.getBoundingClientRect();
        const charX = rect.left + rect.width / 2;
        const charY = rect.top + rect.height / 2;
        
        // Calculate distance
        const dx = charX - x;
        const dy = charY - y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // If in range, apply push effect
        if (distance < radius) {
            // Calculate force (stronger closer to center)
            const force = 1 - (distance / radius);
            
            // Calculate push direction
            const angle = Math.atan2(dy, dx);
            
            // Push distances
            const pushX = Math.cos(angle) * force * 50;
            const pushY = (Math.sin(angle) * force * 30) - 20; // More upward bias
            
            // Apply push effect
            charElem.style.transition = "transform 0.8s cubic-bezier(0.2, 0.8, 0.3, 1.0)";
            charElem.style.transform = `translate(${pushX}px, ${pushY}px) rotate(${(Math.random() - 0.5) * 60}deg)`;
            
            // Enhance visual effect
            charElem.style.transition += ", text-shadow 0.5s, color 0.5s";
            charElem.style.textShadow = `0 0 ${5 + force * 10}px rgba(100, 150, 200, ${0.5 + force * 0.3})`;
            
            // Brighten if close to center
            if (force > 0.5) {
                charElem.style.color = 'rgba(180, 200, 220, 0.95)';
                
                // Reset after effect
                setTimeout(() => {
                    if (charElem.parentNode) {
                        charElem.style.color = '';
                        charElem.style.textShadow = '0 0 5px rgba(100, 150, 200, 0.5)';
                    }
                }, 600);
            }
        }
    });
}

// Create a character fish
function createCharacterFish(x, y) {
    const charElem = document.createElement('div');
    charElem.className = 'character-fish';
    
    // Random character
    charElem.textContent = chars.charAt(Math.floor(Math.random() * chars.length));
    
    // Style
    charElem.style.position = 'absolute';
    charElem.style.left = x + 'px';
    charElem.style.top = y + 'px';
    charElem.style.fontSize = (10 + Math.floor(Math.random() * 8)) + 'px';
    charElem.style.color = 'rgba(167, 182, 199, 0.7)';
    charElem.style.textShadow = '0 0 5px rgba(100, 150, 200, 0.4)';
    
    // Add to ocean
    ocean.appendChild(charElem);
    
    // Start animation
    animateCharacterFish(charElem);
}

// Create some initial character fish
function createInitialCharacters() {
    console.log("Creating initial characters");
    // Create more initial characters for better visual effect
    for (let i = 0; i < 5; i++) {
        const x = Math.random() * window.innerWidth;
        const y = (window.innerHeight * 0.15) + (Math.random() * window.innerHeight * 0.7);
        setTimeout(() => {
            createCharacterFish(x, y);
        }, i * 80);
    }

    

    // Add notification to help players understand the mechanics
    setTimeout(() => {
        const notification = document.createElement('div');
        notification.id = 'game-instruction-popup';
        notification.style.position = 'fixed';
        notification.style.top = '50%';
        notification.style.left = '50%';
        notification.style.transform = 'translate(-50%, -50%)';
        notification.style.background = 'rgba(0, 0, 0, 0.7)';
        notification.style.color = '#a7b6c7';
        notification.style.padding = '15px 20px';
        notification.style.borderRadius = '5px';
        notification.style.fontFamily = 'monospace';
        notification.style.fontSize = '16px';
        notification.style.textAlign = 'left';
        notification.style.zIndex = '1000';
        notification.style.maxWidth = '80%';
        notification.innerHTML = 'Earth has been swallowed by floods. Anthropocene is now a ruin. You are the planet‚Äôs last survivor, yet you are no mortal being.<br>'+
        '<br>You are a shapeless current of WATER, holding the final remnants of memory.<br>'+
        '<br>History, like water, flows into the abyss‚Äî-never to return. As exoplanetary archaeologists scan the remains, you decide what they will find about Earth.<br>'+
        '<br>Water carries everything and erases everything. Do you want to help reconstruct humanity?<br><br><br>';        
        
        // ÂàõÂª∫ÂÖ≥Èó≠ÊåâÈíÆ
        const closeButton = document.createElement('button');
        closeButton.textContent = 'Be Water!';
        closeButton.style.marginTop = '15px';
        closeButton.style.padding = '8px 15px';
        closeButton.style.background = 'rgba(60, 90, 120, 0.7)';
        closeButton.style.border = '1px solid rgba(167, 182, 199, 0.3)';
        closeButton.style.borderRadius = '4px';
        closeButton.style.color = '#a7b6c7';
        closeButton.style.fontFamily = 'monospace';
        closeButton.style.cursor = 'pointer';
        // Ê∑ªÂä†Â±Ö‰∏≠Ê†∑Âºè
        closeButton.style.display = 'block';
        closeButton.style.margin = '15px auto'; // Â∑¶Âè≥Ëá™Âä®Â±Ö‰∏≠
    
        // Ê∑ªÂä†Èº†Ê†áÊÇ¨ÂÅúÊïàÊûú
        closeButton.style.transition = 'background 0.3s';
        closeButton.addEventListener('mouseover', () => {
            closeButton.style.background = 'rgba(80, 120, 160, 0.9)';
        });
        closeButton.addEventListener('mouseout', () => {
            closeButton.style.background = 'rgba(60, 90, 120, 0.7)';
        });
    
        // Ê∑ªÂä†ÁÇπÂáª‰∫ã‰ª∂ - Âè™ÂÖ≥Èó≠ÊèêÁ§∫Ôºå‰∏çËß¶ÂèëÊ∏∏ÊàèËÆ°Êó∂
        closeButton.addEventListener('click', (e) => {
            // ÈòªÊ≠¢‰∫ã‰ª∂ÂÜíÊ≥°ÔºåÈò≤Ê≠¢Ëß¶ÂèëgameContainerÁöÑÁÇπÂáª‰∫ã‰ª∂
            e.stopPropagation();
        
            // Â∞ùËØïÊí≠ÊîæÈü≥È¢ë
            audioElement.play();

            // Ê∑°Âá∫ÊïàÊûú
            notification.style.transition = 'opacity 1.5s';
            notification.style.opacity = '0';
        
            // ÁßªÈô§ÂÖÉÁ¥†
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 1500);
        });
    
        // Â∞ÜÊåâÈíÆÊ∑ªÂä†Âà∞ÈÄöÁü•
        notification.appendChild(document.createElement('br'));
        notification.appendChild(closeButton);
    
        document.body.appendChild(notification);
    }, 1000);
    
       // Periodically spawn new characters to maintain density

    setInterval(() => {
        if (document.querySelectorAll('.character-fish').length < 40) {
            const x = Math.random() * window.innerWidth;
            const y = (window.innerHeight * 0.15) + (Math.random() * window.innerHeight * 0.7);
            createCharacterFish(x, y);
        }
    }, 2000);
    }




// Create rising bubbles from the bottom
function createRisingBubbles(x) {
    const bubbleContainer = document.createElement('div');
    bubbleContainer.style.position = 'absolute';
    bubbleContainer.style.left = (x - 10) + 'px';
    bubbleContainer.style.top = 'calc(100% - 20px)';
    bubbleContainer.style.pointerEvents = 'none';
    bubbleContainer.style.zIndex = '60';
    ocean.appendChild(bubbleContainer);

    const bubbleCount = 12;
    for (let i = 0; i < bubbleCount; i++) {
        const bubble = document.createElement('div');
        bubble.style.position = 'absolute';
        bubble.style.left = (Math.random() * 20) + 'px';
        bubble.style.bottom = '0px';
        bubble.style.width = '6px';
        bubble.style.height = '6px';
        bubble.style.borderRadius = '50%';
        bubble.style.backgroundColor = 'rgba(200, 220, 255, 0.8)';
        bubble.style.opacity = '0.8';
        bubble.style.transform = `scale(${0.5 + Math.random() * 1.5})`;

        const duration = 1500 + Math.random() * 1000;
        const offsetX = (Math.random() - 0.5) * 20;

        bubble.style.transition = `transform ${duration}ms ease-out, bottom ${duration}ms ease-out, opacity ${duration}ms`;
        setTimeout(() => {
            bubble.style.bottom = '100px';
            bubble.style.transform = `translateX(${offsetX}px) scale(1.0)`;
            bubble.style.opacity = '0';
        }, 10);

        setTimeout(() => {
            bubble.remove();
        }, duration + 500);

        bubbleContainer.appendChild(bubble);
    }

    setTimeout(() => bubbleContainer.remove(), 3000);
}

// Enhanced long-press bubbling logic
let bubbleInterval = null;
let bubbleStartTime = null;

function startBubbleFlood(x) {
    bubbleStartTime = Date.now();
    bubbleInterval = setInterval(() => {
        const elapsed = Date.now() - bubbleStartTime;

        const spread = Math.min(300, 100 + elapsed / 5); // ¬±150px
        const count = Math.min(100, 10 + Math.floor(elapsed / 25)); // max 100 per cycle

        for (let i = 0; i < count; i++) {
            const bubble = document.createElement('div');
            bubble.style.position = 'absolute';
            bubble.style.left = (x + (Math.random() * spread - spread / 2)) + 'px';
            bubble.style.top = '85vh'; // bottom of ocean
            const size = 3 + Math.random() * 4;
            bubble.style.width = size + 'px';
            bubble.style.height = size + 'px';
            bubble.style.borderRadius = '50%';
            bubble.style.backgroundColor = 'rgba(200, 220, 255, 0.75)';
            bubble.style.opacity = '0.85';
            bubble.style.pointerEvents = 'none';
            bubble.style.zIndex = '60';
            bubble.style.transform = `scale(${0.6 + Math.random() * 1.4})`;

            const duration = 2000 + Math.random() * 1500;
            const offsetX = (Math.random() - 0.5) * 60;

            bubble.style.transition = `transform ${duration}ms ease-out, top ${duration}ms ease-out, opacity ${duration}ms`;
            ocean.appendChild(bubble);

            setTimeout(() => {
                bubble.style.top = '15vh'; // horizon line
                bubble.style.transform = `translateX(${offsetX}px) scale(1.0)`;
                bubble.style.opacity = '0';
            }, 10);

            setTimeout(() => {
                if (bubble.parentNode) bubble.parentNode.removeChild(bubble);
            }, duration + 500);
        }
    }, 120);
}

function stopBubbleFlood() {
    if (bubbleInterval) {
        clearInterval(bubbleInterval);
        bubbleInterval = null;
    }
}

let ufoCooldown = false;

function summonUFO() {
    // ÁßªÈô§‰ªª‰ΩïÁé∞ÊúâÁöÑUFO (ÈÅøÂÖçÈáçÂè†Ë∞ÉÁî®)
    document.querySelectorAll('.ufo, .beam').forEach(el => el.remove());

    const ufo = document.createElement('div');
    ufo.className = 'ufo';
    document.body.appendChild(ufo);

    const beam = document.createElement('div');
    beam.className = 'beam';
    document.body.appendChild(beam);

    let x = -100; // ‰ªéÂ±èÂπïÂ§ñÂºÄÂßã
    let direction = 1;
    const speed = 2.7;
    
    // Á°Æ‰øùÂÖâÊùüÊ≠£Á°ÆË∑üÈöèUFO
    function alignBeam() {
        // Âü∫‰∫éUFO‰∏≠ÂøÉËÆ°ÁÆóÂÖâÊùü‰ΩçÁΩÆ
        const ufoWidth = ufo.offsetWidth || 128; 
        const beamWidth = beam.offsetWidth || 240; 
        const ufoCenter = x + (ufoWidth / 2);
        const beamLeft = ufoCenter - (beamWidth / 2);
        
        // ËÆæÁΩÆÂÖâÊùü‰ΩçÁΩÆ
        beam.style.left = beamLeft + 'px';
    }

    const interval = setInterval(() => {
        x += speed * direction;
        if (x > window.innerWidth - 100) {
            direction = -1; // ÂêëÂ∑¶ÁßªÂä®
        } else if (x < -100) {
            direction = 1;  // ÂêëÂè≥ÁßªÂä®
        }

        // Êõ¥Êñ∞UFO‰ΩçÁΩÆ
        ufo.style.left = x + 'px';
        
        // Êõ¥Êñ∞ÂÖâÊùü‰ΩçÁΩÆË∑üÈöèUFO
        alignBeam();

        // Â§ÑÁêÜASCIIËâ∫ÊúØÂê∏Êî∂
        document.querySelectorAll('.ascii-art-container').forEach(el => {
            const artRect = el.getBoundingClientRect();
            const beamRect = beam.getBoundingClientRect();
            
            // Ê£ÄÊü•ASCIIËâ∫ÊúØÊòØÂê¶Âú®ÂÖâÊùü‰∏ãÊñπ
            if (artRect.left < beamRect.right && 
                artRect.right > beamRect.left) {
                
                // Ëé∑ÂèñÈ¢úËâ≤Á¥¢ÂºïÂπ∂ËÆ°Êï∞
                const colorIndex = parseInt(el.dataset.colorIndex || 0);
                if (colorIndex === 0) collectedAsciiColors.red++;
                else if (colorIndex === 1) collectedAsciiColors.green++;
                else if (colorIndex === 2) collectedAsciiColors.blue++;
                collectedAsciiColors.total++;
                
                updateCollectionCounter(); // Êõ¥Êñ∞Êî∂ÈõÜËÆ°Êï∞Âô®ÊòæÁ§∫
                
                // Âê∏Ëµ∞ÊïàÊûú
                el.style.transition = 'transform 1.5s ease-in, opacity 1.5s';
                el.style.transform = 'translateY(-200px) scale(0.5)';
                el.style.opacity = '0';
                
                // Âê∏Ëµ∞ASCIIËâ∫ÊúØÊó∂‰∫ßÁîüÂ≠óÁ¨¶Á¢éÁâáÊïàÊûú
                createCharacterDebris(artRect.left + artRect.width/2, artRect.top + artRect.height/2);
                
                // ÁßªÈô§ASCIIËâ∫ÊúØ
                setTimeout(() => {
                    if (el.parentNode) el.parentNode.removeChild(el);
                    // ‰ªéÊ¥ªÂä®ASCIIËâ∫ÊúØË∑üË∏™‰∏≠Âà†Èô§
                    removeFromActiveArts(el.id);
                }, 1500);
            }
        });
    }, 30);
    
    // Âú®ÂÖ®Â±Ä‰øùÂ≠òintervalÂºïÁî®Ôºå‰ª•‰æøÊ∏∏ÊàèÁªìÊùüÊó∂Ê∏ÖÁêÜ
    window.ufoInterval = interval;
}

// Êõ¥Êñ∞Êî∂ÈõÜËÆ°Êï∞Âô®ÊòæÁ§∫
function updateCollectionCounter() {
    const counter = document.getElementById('collection-counter');
    if (counter) {
        counter.textContent = `Á∫¢Ëâ≤: ${collectedAsciiColors.red} | ÁªøËâ≤: ${collectedAsciiColors.green} | ËìùËâ≤: ${collectedAsciiColors.blue}`;
    }
}

// Ê∑ªÂä†Êñ∞ÂáΩÊï∞ÔºöÂàõÂª∫Â≠óÁ¨¶Á¢éÁâáÊïàÊûú


function createCharacterDebris(x, y) {
    // ÂΩìÂâçÊ≠£Âú®Ë¢´Âê∏Êî∂ÁöÑÂ≠óÁ¨¶ÁîªÊï∞Èáè
    const activeAbsorptions = document.querySelectorAll('.ascii-art-container[style*="transform: translateY(-200px)"]').length;
    // Ê†πÊçÆÂêåÊó∂Âê∏Êî∂ÁöÑÊï∞ÈáèË∞ÉÊï¥Á≤íÂ≠êÊï∞
    const debrisCount = Math.max(5, Math.floor((8 + Math.floor(Math.random() * 7)) / Math.max(1, activeAbsorptions)));
    
    for (let i = 0; i < debrisCount; i++) {
        const charElem = document.createElement('div');
        charElem.className = 'character-fish';
        
        // ÈöèÊú∫Â≠óÁ¨¶
        charElem.textContent = chars.charAt(Math.floor(Math.random() * chars.length));
        
        // ÂÆö‰ΩçÂú®ASCIIËâ∫ÊúØÁöÑ‰∏≠ÂøÉ
        charElem.style.position = 'absolute';
        charElem.style.left = x + 'px';
        charElem.style.top = y + 'px';
        charElem.style.fontSize = (10 + Math.floor(Math.random() * 8)) + 'px';
        charElem.style.color = 'rgba(167, 182, 199, 0.9)';
        charElem.style.textShadow = '0 0 5px rgba(100, 150, 200, 0.5)';
        charElem.style.zIndex = '200';
        
        // Ê∑ªÂä†Âà∞Êµ∑Ê¥ã
        ocean.appendChild(charElem);
        
        // ËÆ°ÁÆóÈöèÊú∫ÊñπÂêë
        const angle = Math.random() * Math.PI * 2;
        const distance = 20 + Math.random() * 80;
        const duration = 1000 + Math.random() * 1500;
        
        // Âä®ÁîªÁàÜÁÇ∏ÊïàÊûú
        setTimeout(() => {
            charElem.style.transition = `transform ${duration}ms cubic-bezier(0.2, 0.8, 0.3, 1.0), opacity ${duration}ms`;
            
            const destX = Math.cos(angle) * distance;
            const destY = Math.sin(angle) * distance;
            
            charElem.style.transform = `translate(${destX}px, ${destY}px) rotate(${Math.random() * 360}deg)`;
            
            // ËÆ©‰∏Ä‰∫õÂ≠óÁ¨¶ÊºÇÊµÆÔºå‰∏Ä‰∫õÊ∂àÂ§±
            if (Math.random() > 0.3) {
                setTimeout(() => {
                    animateCharacterFish(charElem);
                }, duration);
            } else {
                // Ê∑°Âá∫Âπ∂ÁßªÈô§
                charElem.style.opacity = '0';
                setTimeout(() => {
                    if (charElem.parentNode) charElem.parentNode.removeChild(charElem);
                }, duration);
            }
        }, 10);
    }
}




// Run initialization
setTimeout(createInitialCharacters, 500);
});

window.addEventListener("load", () => {
    const ufo = document.querySelector('.ufo');
    const beam = document.querySelector('.beam');
    const ufoImg = ufo?.querySelector('img');

    if (!ufo || !beam || !ufoImg) return;

    function alignBeam() {
        const ufoRect = ufo.getBoundingClientRect();
        const beamWidth = beam.offsetWidth;
        const ufoCenter = ufo.offsetLeft + ufo.offsetWidth / 2;
        const beamLeft = ufoCenter - beamWidth / 2;
        beam.style.left = beamLeft + "px";
    }

    if (ufoImg.complete) {
        alignBeam();
    } else {
        ufoImg.addEventListener('load', alignBeam);
    }

    window.addEventListener('resize', alignBeam);
});

</script>

</body>
</html>
